#!/bin/bash
#
# Usage: dis-remote [OPTIONS] CMD [args]
# communicate with a remote server
#
# CMD
#   grep    takes key=regexp pairs and returns matching messages
#   pull    takes one or more hash prefixes and returns the messages
#   push    takes a message hash and uploads it to the server
#
# OPTIONS
#   -s, --server [HOST]      the host to send to
#                            default is DIS_HOST or localhost
#   -p, --port [PORT]        the port on the host
#                            default is DIS_PORT or 4444
#   -j, --json               leave the results as raw JSON
#   -n, --dry-run            print to STDOUT instead of the server
#
# TODO:
# - don't re-sort the messages between grep and pull
# 
. $(dirname $0)/dis-common
if [ -z $DIS_HOST ];then HOST=localhost;else HOST=$DIS_HOST;fi
if [ -z $DIS_PORT ];then PORT=4444;    else  PORT=$DIS_PORT;fi
options -o s:p:jn -l server:,port:,json,dry-run -- "$@"
while [ $# -gt 0 ];do
    case $1 in
        -s|--server)  HOST="$2"; shift;;
        -p|--port)    PORT="$2"; shift;;
        -j|--json)    JSON="yes";;
        -n|--dry-run) DRY="yes";;
        (--) shift; break;;
        (-*) error "$0: error -- unrecognized option $1";;
        (*)  break;;
    esac
    shift
done

cmd=$1; shift
if [ "$1" == "-" ];then args="$(cat -)";else args="$@";fi

run(){
    case $cmd in
        pull) echo -E "pull $(to_array  $args)";;
        push) echo -E "push [$(echo -n "$args"|tr '\n' ',')]";;
        grep) echo -E "grep $(to_object $args)";;
    esac
}

if [ ! -z "$DRY" ];then
    RESULT="$(run)"
else
    RESULT="$(run|netcat "$HOST" "$PORT")"
fi

if [ ! -z "$JSON" ];then
    echo "$RESULT"
else
    case $cmd in
        pull)
            for i in $(seq $(echo "$RESULT"|jshon -l)|tac);do
                show_msg "$(echo "$RESULT"|jshon -e $i)"
            done;;
        push|grep)
            COUNT=$(echo "$RESULT"|jshon -l)
            if [ ! "$COUNT" == "0" ];then
                echo "$RESULT"|jshon -a -u
            fi;;
    esac
fi
