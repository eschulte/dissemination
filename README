#                                                         -*- org -*-
#+Title: A System/Protocol for information dissemination.

* Overview
  :PROPERTIES:
  :CUSTOM_ID: overview
  :END:

A distributed system through which named or anonymous *users* can
disseminate *messages*.

If Usenet and Twitter had a paranoid child.

** Users
- Any named user must be associated with a PGP public key
- Any non-anonymous message must be signed by its sender

*** What other information should be associated with a sender?
- real name
- URL
- arbitrary text
- small picture

You could always allow a username to be associated with a hash, and
allow any key/value pairs, as long as one of them is a pgp public key.
But there is a benefit to actually putting things into the spec, so
you don't get 15 different versions of an icon from 15 different
clients.  If so, what is important/general enough to go into the spec,
and what should be required or just optional?

My only firm feeling on this is that a "real name" field be optional.

** Structure of a Message
A message is just a key-value store with some rules about which keys
are required when.

Required keys:
- ID :: a hash of every part of the message *but* the ID key and
     value.  Are there any other parts of the message which
     should *not* be included in the signature?  Should the signature
     include a specification of the keys that it is generated from?

Optional keys:
- Sender :: this value would need two parts, the name of the sender,
     and a PGP signature for every other part of the message aside
     from the ID
- Contents :: holding either plain text or mime-encoded data.
  - Should some sort of mime header be required?
  - Should this be email-compatible?
  - This may be encrypted (should that be a different field)
  - Should this be required
- Target :: this could specify users or groups to target.  This
     should probably just hold another key-value pair in which the
     key could be the type of thing targeted and the value could be
     the identifier.  E.g.,
     | group | alt.foo  |
     | user  | john.doe |
     Should this be extensible or should the keys be fixed.
- Subject :: is this required?
- Time To Live :: does this make sense?

Should misc other keys be allowed? why not

*** internal references
There are times when you want to reference another part of the same
message, e.g., when you want to include images to be references from
an html portion.  What should the syntax be for this?  Are existing
email mime rules sufficiently powerful enough to handle this?

This should probably be set in the standard.

** Distribution of Messages
Along the same lines as Usenet.  Users connect to servers, and servers
exchange information betwixt themselves.

The biggest difference between this and usenet would be the
expectation that the inter-server exchange is somewhat more
timely/real-time, i.e., not just 2 batch transfers per day.

** Organization and discovery of Messages
Methods for the discovery of messages
- sender
- keyword search
- messages may target a user
- messages may target a group
- arbitrarily extensible headers?
- servers can add their own discovery methods

* Tools
** JSON -- Message serialization
This seems like the obvious data format for a message hash.

** PGP for message signing, verification, encryption and decryption
** USENET -- distributed submission, storage, persistence and discovery
This is the perfect model for distribution, it just needs:
- faster dissemination (closer to real time than twice-daily batches)
- a less hierarchical system of organization
  (users and keywords rather than newsgroups)

- [[http://tools.ietf.org/html/rfc1036][Standard for Interchange of USENET Messages]]

- keyword search
  - see [[#usenet-archiving-and-searching][Usenet Archiving and Searching]]
- tables: e.g., for association of
  - user names → URL/URI ??
  - user names → public keys

*** Usenet Archiving and Searching
    :PROPERTIES:
    :CUSTOM_ID: usenet-archiving-and-searching
    :END:
- 'lq-text' package, by Liam Quin
- http://en.wikipedia.org/wiki/X-No-Archive

** MIME -- content serialization
will need to allow multipart messages
- being as similar as email would be good
- learning from email would also be good

** gzip -- on the wire compression
We shouldn't worry about compression, just let some standard library
compress messages or groups of messages on the wire or on the disk.

This may require another piece on information s.t. compressed
messages are sent with the message key.

* Protocol
  :PROPERTIES:
  :CUSTOM_ID: protocol
  :END:
This is the main goal, but may need to wait until we've formalized the
above and written some reference implementations.

* Library
Highly related to [[#protocol]].

What would application writers want in an API?

Both clients and servers.
- package :: from JSON message to signed or encrypted and ready for
     dumping through an external compression engine.

* Notes
** Relevant Links
*** Twitter-like services
- http://www.twhirl.org/
- http://pownce.com/
- http://www.jaiku.com/
- http://www.sixapart.com/
- http://www.jabber.org/

*** Twitter Clones and RFCs for twitter-like API
   :PROPERTIES:
   :ID:       e6e05b9e-651a-4ab9-9ca8-bf7728f8278d
   :END:
- http://www.hanselman.com/blog/RFCOpenTweetsWhyIsMicrobloggingCentralized.aspx
  (look at the comments)
- http://www.russellbeattie.com/blog/peep-an-open-twitter-server
- http://ilya.netapt.com/blog/archive/2008/05/03/opentweet-distributed-twitter-like-service/
- http://orangejuiceliberationfront.com/building-a-distributed-twitter/
- http://inessential.com/2011/03/11/alternative_to_twitter_
- http://redis.io/topics/twitter-clone

** Use cases
- some from links at [[id:e6e05b9e-651a-4ab9-9ca8-bf7728f8278d][RFC twitter-like API]]
- similar to
  - twitter style information dissemination
  - social information posting and reading

*** find a feed
just use web pages, or integrate into the spec

*** listing microblogs
will need some sort of title, meta-information or summary
(note: meta-information gathering is a common form of warentless surveillance)

*** subscribing
*** replies
*** keyword searching
    :PROPERTIES:
    :CUSTOM_ID: keyword-searching
    :END:

*** hashtags
Apparently these arose organically from the keyword search mechanisms
built into twitter.  So it would seem that this is simply a subset of
[[#keyword-searching]].

Clients may make these clickable on their own.

*** direct addressing
- some form of universal addressing (see [[#overview]] points)
- likely some need for abbreviated names or distributed table linking
  names to URIs

*** CLI friendly
e.g., cat a remote resource and pipe the result into a program.
: cat friend:some/movies.mov|mplayer
** how to identify sub-point resources
e.g., how can I browse the messages available from some end point.
- file system?
- temporal feed?
- must respect the groups and permissions set by that end point

This use case comes from more of a hosted model, where as the rest of
the system is moving into a more push-based model.

** DKIM -- combat spam / something analogous?
- DKIM :: Domain Keys Identified Mail (see http://www.dkim.org/)
     Messages are signed with the public key of the sending domain.
     This prevents forgery of the from domain line.

Would it make sense to do something analogous?

There is already the need for every message to be signed by the
sender, so, a spammer would be forced to use a valid name in the From
field.  I guess in this case the solution would be to throttle the
generation of new names.  Or possibly require a new name to have at
least one signature in the web of trust or something.
