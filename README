#                                                         -*- org -*-
#+Title: A System/Protocol for information dissemination.

* Overview
  :PROPERTIES:
  :CUSTOM_ID: overview
  :END:

A distributed system through which named or anonymous *users* can
disseminate *messages*.

If Usenet and Twitter had a paranoid child.

** Users
- Any named user must be associated with a PGP public key
- Any non-anonymous message must be signed by its sender

*** What other information should be associated with a sender?
- real name
- URL
- arbitrary text
- small picture

You could always allow a username to be associated with a hash, and
allow any key/value pairs, as long as one of them is a pgp public key.
But there is a benefit to actually putting things into the spec, so
you don't get 15 different versions of an icon from 15 different
clients.  If so, what is important/general enough to go into the spec,
and what should be required or just optional?

My only firm feeling on this is that a "real name" field be optional.

** Structure of a Message
A message is just a key-value store with some rules about which keys
are required when.

*** signing and encrypting
    :PROPERTIES:
    :CUSTOM_ID: signing-and-encrypting
    :END:

Will want signature and encryption to apply to as much of the message
(including meta data) as possible.  What is the minimum required to
show for each use case.

- signed would require
  - array of hash keys in the order they are signed and hashed
  - hash of everything else
  - name of the signer
  - detached signature of everything else
  - JSON dictionary

- encrypted
  - name of recipients
  - hash of encrypted data
  - blob of encrypted data, serialized to JSON dictionary

- signed and encrypted
  - name of sender
  - name of recipients
  - hash of encrypted data
  - detached signature of blob of encrypted data
  - blob of encrypted data, serialized to JSON dictionary

- anonymous (neither signed nor encrypted)
  - array of hash keys in the order they are hashed
  - hash
  - JSON dictionary

*** structure of JSON dictionary
Required keys:

Optional keys:
- contents :: holding either plain text or mime-encoded data.
  - Should some sort of mime header be required?
  - Should this be email-compatible?
  - This may be encrypted (should that be a different field)
  - Should this be required
- subject :: This should not be required.  Maybe this should be forced
     to conform to whatever restrictions are placed on subject lines
     in emails.
- date :: optionally specify when this was sent, I don't know if
     validation should be performed on this key.  Probably not,
     because how would a server know when a message entered the
     system.
- time-to-live :: does this make sense?  lets use the =at=
     notation. if this is a relative time then a date key would also
     be required.

Arbitrary other keys should be allowed.

*** internal references
There are times when you want to reference another part of the same
message, e.g., when you want to include images to be references from
an html portion.  What should the syntax be for this?  Are existing
email mime rules sufficiently powerful enough to handle this?

This should probably be set in the standard.

** Distribution of Messages
Along the same lines as Usenet.  Users connect to servers, and servers
exchange information betwixt themselves.

The biggest difference between this and usenet would be the
expectation that the inter-server exchange is somewhat more
timely/real-time, i.e., not just 2 batch transfers per day.

** Organization and discovery of Messages
Methods for the discovery of messages
- sender
- keyword search
- messages may target a user
- messages may target a group
- arbitrarily extensible headers?
- servers can add their own discovery methods

* Tools
** JSON -- Message serialization
This seems like the obvious data format for a message hash.

** PGP for message signing, verification, encryption and decryption
** USENET -- distributed submission, storage, persistence and discovery
This is the perfect model for distribution, it just needs:
- faster dissemination (closer to real time than twice-daily batches)
- a less hierarchical system of organization
  (users and keywords rather than newsgroups)

- [[http://tools.ietf.org/html/rfc1036][Standard for Interchange of USENET Messages]]

- keyword search
  - see [[#usenet-archiving-and-searching][Usenet Archiving and Searching]]
- tables: e.g., for association of
  - user names → URL/URI ??
  - user names → public keys

*** Usenet Archiving and Searching
    :PROPERTIES:
    :CUSTOM_ID: usenet-archiving-and-searching
    :END:
- 'lq-text' package, by Liam Quin
- http://en.wikipedia.org/wiki/X-No-Archive

** MIME -- content serialization
will need to allow multipart messages
- being as similar as email would be good
- learning from email would also be good

** gzip -- on the wire compression
We shouldn't worry about compression, just let some standard library
compress messages or groups of messages on the wire or on the disk.

This may require another piece on information s.t. compressed
messages are sent with the message key.

* Protocol
  :PROPERTIES:
  :CUSTOM_ID: protocol
  :END:
This is the main goal, but may need to wait until we've formalized the
above and written some reference implementations.

* Library
Highly related to [[#protocol]].

What would application writers want in an API?

Should the API handle indexing/searching or should this be left up to
the servers (this question can probably wait)?

Both clients and servers.
- package :: from JSON message to signed or encrypted and ready for
     dumping through an external compression engine.
- un-package :: take a packed message and return a unpacked -- throw
     an error if signature verification or decryption fails
- handle incoming :: takes a function to call on each incoming
     message (after decompression and un-packaging)

* Notes
** Relevant Links
*** Twitter-like services
- http://www.twhirl.org/
- http://pownce.com/
- http://www.jaiku.com/
- http://www.sixapart.com/
- http://www.jabber.org/

*** Twitter Clones and RFCs for twitter-like API
   :PROPERTIES:
   :ID:       e6e05b9e-651a-4ab9-9ca8-bf7728f8278d
   :END:
- http://www.hanselman.com/blog/RFCOpenTweetsWhyIsMicrobloggingCentralized.aspx
  (look at the comments)
- http://www.russellbeattie.com/blog/peep-an-open-twitter-server
- http://ilya.netapt.com/blog/archive/2008/05/03/opentweet-distributed-twitter-like-service/
- http://orangejuiceliberationfront.com/building-a-distributed-twitter/
- http://inessential.com/2011/03/11/alternative_to_twitter_
- http://redis.io/topics/twitter-clone

** Use cases
- some from links at [[id:e6e05b9e-651a-4ab9-9ca8-bf7728f8278d][RFC twitter-like API]]
- similar to
  - twitter style information dissemination
  - social information posting and reading

*** find a feed
just use web pages, or integrate into the spec

*** listing microblogs
will need some sort of title, meta-information or summary
(note: meta-information gathering is a common form of warentless surveillance)

*** subscribing
*** replies
*** keyword searching
    :PROPERTIES:
    :CUSTOM_ID: keyword-searching
    :END:

*** hashtags
Apparently these arose organically from the keyword search mechanisms
built into twitter.  So it would seem that this is simply a subset of
[[#keyword-searching]].

Clients may make these clickable on their own.

*** direct addressing
- some form of universal addressing (see [[#overview]] points)
- likely some need for abbreviated names or distributed table linking
  names to URIs

*** CLI friendly
e.g., cat a remote resource and pipe the result into a program.
: cat friend:some/movies.mov|mplayer
** how to identify sub-point resources
e.g., how can I browse the messages available from some end point.
- file system?
- temporal feed?
- must respect the groups and permissions set by that end point

This use case comes from more of a hosted model, where as the rest of
the system is moving into a more push-based model.

** DKIM -- combat spam / something analogous?
- DKIM :: Domain Keys Identified Mail (see http://www.dkim.org/)
     Messages are signed with the public key of the sending domain.
     This prevents forgery of the from domain line.

Would it make sense to do something analogous?

There is already the need for every message to be signed by the
sender, so, a spammer would be forced to use a valid name in the From
field.  I guess in this case the solution would be to throttle the
generation of new names.  Or possibly require a new name to have at
least one signature in the web of trust or something.
** GPGME -- the GPG C API
for a reference implementation, assuming we don't want to just call
gpg on the command line.  See [[info:gpgme#Top]].
** How to hide recipients on encrypted messages
s.t. only a recipient of the messages can see that they are a
recipient, yet they can still efficiently query a server for those
such messages (i.e., either through providing some sort of homomorphic
comparison key, or a black box function which the server can run to
check).
